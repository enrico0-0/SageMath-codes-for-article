# SageMath-code2-for-article

precisione_bit = 4000  
phi = (1 + sqrt(5)) / 2

A = 21
B = phi
M = 48 * (10**46) 
soglia_denominatore = 6 * M
soglia_denominatore_sage = Integer(soglia_denominatore)

gamma_sym = log(2) / log(phi)
gamma_approx = gamma_sym.n(prec=precisione_bit)

min_diff_nm = 0
max_diff_nm = 247
max_candidates_q = 10 

def distance_from_nearest_integer(x):
    """Calcola la distanza di x dall'intero più vicino, ||x||."""
    x = x.n(prec=precisione_bit)
    frac_part = x - floor(x)
    return min(frac_part, 1 - frac_part)

cf = continued_fraction(gamma_approx)
convergenti = cf.convergents()
q_candidates = []
q_start_index = -1
max_iter_q = 200 

print(f"--- FASE 1: Ricerca Denominatore q > 6M ({soglia_denominatore_sage}) ---")

for i in range(max_iter_q):
    try:
        q = convergenti[i].denominator()
        if q > soglia_denominatore_sage:
            q_start_index = i
            break
    except Exception:
        break

if q_start_index == -1:
    print("ERRORE: Nessun denominatore q trovato con q > soglia.")
else:
    for i in range(q_start_index, q_start_index + max_candidates_q):
         try:
             q_candidates.append((i, convergenti[i].denominator()))
         except IndexError:
             break
    
    max_bound_min = 0 # Questo sarà il MAX di tutti i MINIMI
    q_max_bound_min = 0
    max_nm_result = 0
    
    print(f"\n--- FASE 2: Calcolo Max(Min(Bound)) per n-m da {min_diff_nm} a {max_diff_nm} ---")
    print("n-m | Indice q | Denominatore q | ||eta*q|| | ||gamma*q|| | Epsilon | BOUND MINIMO (n-l)")
    print("---------------------------------------------------------------------------------------------------------------------------------------------")

    for diff_nm in range(min_diff_nm, max_diff_nm + 1):
        try:
            nuovo_eta_sym = (log(5 / (1 + phi^(-2*diff_nm))) / log(phi))
            nuovo_eta_approx = nuovo_eta_sym.n(prec=precisione_bit)
        except Exception:
            continue
            
        min_bound_for_nm = Infinity 
        q_min_for_nm = None
        epsilon_min_for_nm = None
        eta_min_for_nm = None
        gamma_min_for_nm = None
        indice_q_min_for_nm = None


        for indice_q, q_trovato in q_candidates:
            
            distance_gamma = distance_from_nearest_integer(gamma_approx * q_trovato)
            distance_eta = distance_from_nearest_integer(nuovo_eta_approx * q_trovato)
            epsilon = distance_eta - M * distance_gamma
            
            if epsilon > 0:
                argomento_log = (A * q_trovato) / epsilon
                risultato_finale = (log(argomento_log) / log(B)).n(digits=10)
                
                if risultato_finale < min_bound_for_nm:
                    min_bound_for_nm = risultato_finale
                    q_min_for_nm = q_trovato
                    epsilon_min_for_nm = epsilon
                    eta_min_for_nm = distance_eta
                    gamma_min_for_nm = distance_gamma
                    indice_q_min_for_nm = indice_q

        if min_bound_for_nm != Infinity:
           
            if min_bound_for_nm > max_bound_min:
                max_bound_min = min_bound_for_nm
                q_max_bound_min = q_min_for_nm
                max_nm_result = diff_nm

            print(f"{diff_nm:3} | {indice_q_min_for_nm:8} | {q_min_for_nm:14} | {eta_min_for_nm.n(digits=3):9} | {gamma_min_for_nm.n(digits=3):9} | {epsilon_min_for_nm.n(digits=3):9} | {min_bound_for_nm}")
        else:
            print(f"{diff_nm:3} | - | - | - | - | - | FALLITO (epsilon <= 0 per tutti i q candidati)")
    
    print("\n--------------------------------------------------------------")
    if max_bound_min > 0:
        print("RISULTATO FINALE (Massimo Bound tra tutti i minimi):")
        print(f"VALORE MAX(MIN) TROVATO: {max_bound_min.n(digits=10)}")
        print(f"ARROTONDAMENTO PER ECCESSO (Bound definitivo): {max_bound_min.ceil()}")
        print(f"GENERATO PER n-m = {max_nm_result}")
        print(f"DENOMINATORE q CHE HA GENERATO IL BOUND MASSIMO TRA I MINIMI:")
        print(f"{q_max_bound_min}")
    else:
        print("Il metodo di riduzione non ha trovato un bound valido (epsilon <= 0) tra i candidati testati.")
    print("--------------------------------------------------------------")
